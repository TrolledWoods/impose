///
/// The very very temporary and not very good impose standard libary!
/// 

vec :: import "vec";

print :: |message: &- U8| {
	raw := bit_cast { pointer: &U8, length: U64 } (message);

	if raw.length {
		length := raw.length - 1;
		index := 0;

		{:end_loop
			loop {
				if length < index { 
					skip :end_loop;
				};

				put_char(*(raw.pointer + index));

				index = index + 1;
			};
		};
	};

	flush();
};

/// Prints out a number more easily
debug :: |name: &- U8, value: U64| {
	print(name);
	print(": ");
	print_num(value);
	print("\n");
};

/// A pointer buffer in a raw version.
/// TODO: Flag this as not storable in constants!
PointerBufferRaw :: type {
	pointer: &U64,
	length: U64,
};

/// Allocates a pointer buffer of u64 elements
/// TODO: Make this function polymorphic.
alloc_u64 :: |n_elements: U64| {
	pointer := buffer_into_raw(alloc(n_elements * 8, 8)).pointer;
	buffer_from_raw(struct { pointer: pointer, length: n_elements })
};

alloc_u8 :: |n_elements: U64| {
	pointer := bit_cast { pointer: &U64, length: U64 } (alloc(n_elements, 1)).pointer;
	bit_cast &- U8 (struct { pointer: pointer, length: n_elements })
};

dealloc_buffer_u64 :: |buffer: &- U64| {
	raw := buffer_into_raw(buffer);
	dealloc(raw.pointer, raw.length * 8, 8);
};

/// Turns a pointer buffer into a PointerBufferRaw.
/// TODO: Make this generic
buffer_into_raw :: |buffer: &- U64| {
	bit_cast PointerBufferRaw (buffer)
};

/// Turns a PointerBufferRaw into a pointer buffer
/// TODO: Make this generic
buffer_from_raw :: |raw: PointerBufferRaw| {
	bit_cast &- U64 (raw)
};

/// Gets a pointer to a specific element in a pointer buffer.
buffer_get :: |buffer: &- U64, index: U64| {
	pointer := buffer_into_raw(buffer).pointer;
	pointer + index
};

buffer_length :: |buffer: &- U64| buffer_into_raw(buffer).length;

/// Iterates over every element in a buffer, and runs the callback on each one,
/// toegher with the index.
buffer_iterate :: |buffer: &- U64, callback: (U64, &U64)| {
	buffer_iterate_any(buffer, |a: U64, b: &U64, c: &{}| {
		(bit_cast (U64, &U64) (c))(a, b)
	}, bit_cast &{} (callback));
};

/// Iterate with any data attached.
buffer_iterate_any :: |buffer: &- U64, callback: (U64, &U64, &{}), any: &{}| {
	raw := buffer_into_raw(buffer);

	if raw.length {
		length := raw.length - 1;
		index := 0;

		{:end_loop
			loop {
				if length < index { 
					skip :end_loop;
				};

				callback(index, raw.pointer + index, any);

				index = index + 1;
			};
		};
	};
};
