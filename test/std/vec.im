Vector :: type {
	buffer: &- U64,
	length: U64,
};

create :: || {
	raw := struct {
		pointer: bit_cast &U64 (0),
		length: 0,
	};
	length := 0;
	struct { buffer: buffer_from_raw(raw), length: length }
};

free :: |vec: Vector| {:skip_free
	buffer := vec.buffer;
	if buffer_into_raw(buffer).length < 1 {
		// If the buffer has no data, it is not a valid poitner,
		// so it makes no sense to free it.
		skip :skip_free;
	};

	dealloc_buffer_u64(buffer);
};

/// Returns a buffer which is a subsection of the vector
slice :: |vec: &Vector, start: U64, end: U64| {
	pointer := buffer_into_raw((*vec).buffer).pointer;

	pointer = pointer + bit_cast &U64 (start * 8);
	length := end - start;

	buffer_from_raw(struct { pointer: pointer, length: length })
};

slice_full :: |vec: &Vector| {
	slice(vec, 0, (*vec).length)
};

capacity :: |vec: &Vector| {
	buffer_into_raw((*vec).buffer).length
};

reserve :: |vec: &Vector, min_capacity: U64| {
	capacity := capacity(vec);
	if capacity < min_capacity {
		new_buffer := alloc_u64(min_capacity + 10);
		// Copy data into new buffer
		buffer_iterate_any(slice(vec, 0, (*vec).length), |index: U64, value: &U64, any: &{}| {
			new_buffer := *bit_cast & &- U64 (any);
			*buffer_get(new_buffer, index) = *value;
		}, bit_cast &{} (&new_buffer));

		dealloc_buffer_u64((*vec).buffer);
		(*vec).buffer = new_buffer;
	};
};

push :: |vec: &Vector, value: U64| {
	reserve(vec, (*vec).length + 1);
	*get(vec, (*vec).length) = value;
	(*vec).length = (*vec).length + 1;
};

get :: |vec: &Vector, index: U64| {
	buffer_get((*vec).buffer, index)
};
