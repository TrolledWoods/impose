Complex :: type {
	real: F64,
	imag: F64,
};

create :: |real: F64, imag: F64| struct { real: real, imag: imag };

add :: |a: Complex, b: Complex| {
	struct {
		real: a.real + b.real,
		imag: a.imag + b.imag,
	}
};

sub :: |a: Complex, b: Complex| {
	struct {
		real: a.real - b.real,
		imag: a.imag - b.imag,
	}
};

mul :: |a: Complex, b: Complex| {
	struct {
		real: a.real * b.real - a.imag * b.imag,
		imag: a.real * b.imag + a.imag * b.real,
	}
};

SOLID    :: *"#".pointer;
ALMOST   :: *"*".pointer;
SOMEWHAT :: *"'".pointer;
EMPTY    :: *" ".pointer;
NEW_LINE :: *"\n".pointer;

true  :: 1 > 0;
false :: 0 > 1;

print_mandelbrot :: |center_x: F64, center_y: F64, size: F64, window_size: U64, aspect: F64| {
	sum := 0.0;
	i := window_size;
	units_per_pixel := size / loop {
		sum = sum + 0.5;
		if (i = i-1) <= 0  skip loop sum;
	};

	y := center_y + size;
	dy := units_per_pixel / aspect;
	dx := units_per_pixel;
	end_y := center_y - size;

	column := alloc(window_size + 1, 1);
	*(column + window_size) = NEW_LINE;

	loop :y_loop {
		x := center_x - size;
		i := 0;
		loop :x_loop {
			c := complex\create(x, y);
			z := complex\create(0.0, 0.0);

			iters := 0;
			is_valid := loop {
				z = complex\add(complex\mul(z, z), c);

				if z.real * z.real + z.imag * z.imag >= 4.0 {
					skip loop (false);
				};

				iters = iters + 1;
				if iters > 500 {
					skip loop (true);
				};
			};

			*(column + i) =
				    if is_valid    SOLID 
			   else if iters > 20  ALMOST 
			   else if iters > 10  SOMEWHAT
			   else                EMPTY;

			x = x+dx;
			if (i = i+1) >= window_size  skip :x_loop;
		};

		print(bit_cast &-U8 (struct { pointer: column, length: window_size + 1 }));

		if (y = y-dy) < end_y  skip :y_loop;
	};

	// free(column, window_size + 1, 1);
};
